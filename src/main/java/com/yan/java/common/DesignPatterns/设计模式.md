base on the following principles of object orientated design.
    1. program to an interface not an implementation
    2. favor object composition over inheritance

1.单例模式
  一个类有且只有一个对象
  推荐:

2.原型模式
  原型模式属于对象的创建模式。通过给出一个原型对象来指明所有创建的对象的类型，然后用复制这个原型对象的办法创建出更多同类型的对象。
  这就是选型模式的用意。
  Object::clone
  要实现对象的clone，实现Cloneable接口 调用 clone方法即可实现对象的克隆
  但是这种方式只是浅克隆，只是克隆了对象，但是对象内的成员如对象成员变量拷贝前后还是一样的对象。
  -->>> 使用反序列化实现深拷贝 或者在clone方法内部拷贝所有成员
3.工厂模式
 3.1 简单工厂模式
  简单定义：一个工厂生产所有的工具。但这个工厂不是万能的
  我们需要工具的时候，并不需要自己去创造，可以通过工厂获取。
  优点：对创建的对象进行加工处理，而使用的时候并不知道加工细节。
  缺点：业务中很多与对象创建相关的代码，每个方法都要写许多的对应代码。后期很容易导致简单工厂类臃肿，耦合度高。
  简单的描述: 一个工厂生产所有类别产品。
 3.2 工厂模式
  对简单工厂模式的解耦。
  一个工具由一个工厂生产。
  优点，代码不会耦合到一个类里面。
  缺点同样明显，没增加一个工具，就需要添加一个工厂类。当工具非常多的时候，需要创建的工厂类也非常多。
  简单的描述：一个总工厂，下有多个子工厂，每个子工厂生产一类产品
 3.3 抽象工厂模式
  工厂模式：一个工厂->多个子工厂，子工厂只生产特定的产品，子产品产品只是某个特性不同。如 正方形工厂，圆工厂
  抽象工厂：一个工厂->多个子工厂，子工厂生产的产品完全不同，只是抽取产品的相同类型属性(接口)，形成抽象接口。
  如手机和D盘完全不搭架，但是可以抽取他们都具备 颜色 形状 名字 id 等属性形成接口
   优点：一个抽象工厂其所有子工厂生产的产品都在一些地方存在一定的关联。
    从而可以在类内部对产品族的关联关系进行定义和描述，不必引入一个新的类来进行管理
   缺点：产品族扩展是一件非常费力的事情。如现在抽象工厂需要引入一个所有产品新的属性 如 价格，那么所有工厂类都需要修改.


