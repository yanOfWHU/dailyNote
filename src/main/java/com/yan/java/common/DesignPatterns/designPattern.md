base on the following principles of object orientated design.
    1. program to an interface not an implementation
    2. favor object composition over inheritance

1.单例模式
  一个类有且只有一个对象
  推荐:  1. 枚举方式
        2. 静态内部类方式，单例对象在静态内部类做静态成员变量
        3. 使用静态 volatile 对象，同时获取对象时，双重判断
2.原型模式
  原型模式属于对象的创建模式。通过给出一个原型对象来指明所有创建的对象的类型，然后用复制这个原型对象的办法创建出更多同类型的对象。
  这就是选型模式的用意。
  Object::clone
  要实现对象的clone，实现Cloneable接口 调用 clone方法即可实现对象的克隆
  但是这种方式只是浅克隆，只是克隆了对象，但是对象内的成员如对象成员变量拷贝前后还是一样的对象。
  -->>> 使用反序列化实现深拷贝 或者在clone方法内部拷贝所有成员
3.工厂模式
 3.1 简单工厂模式
  简单定义：一个工厂生产所有的工具。但这个工厂不是万能的
  我们需要工具的时候，并不需要自己去创造，可以通过工厂获取。
  优点：对创建的对象进行加工处理，而使用的时候并不知道加工细节。
  缺点：业务中很多与对象创建相关的代码，每个方法都要写许多的对应代码。后期很容易导致简单工厂类臃肿，耦合度高。
  简单的描述: 一个工厂生产所有类别产品。
 3.2 工厂模式
  对简单工厂模式的解耦。
  一个工具由一个工厂生产。
  优点，代码不会耦合到一个类里面。
  缺点同样明显，没增加一个工具，就需要添加一个工厂类。当工具非常多的时候，需要创建的工厂类也非常多。
  简单的描述：一个总工厂，下有多个子工厂，每个子工厂生产一类产品
 3.3 抽象工厂模式
  工厂模式：一个工厂->多个子工厂，子工厂只生产特定的产品，子产品产品只是某个特性不同。如 正方形工厂，圆工厂
  抽象工厂：一个工厂->多个子工厂，子工厂生产的产品完全不同，只是抽取产品的相同类型属性(接口)，形成抽象接口。
  如手机和D盘完全不搭架，但是可以抽取他们都具备 颜色 形状 名字 id 等属性形成接口
   优点：一个抽象工厂其所有子工厂生产的产品都在一些地方存在一定的关联。
    从而可以在类内部对产品族的关联关系进行定义和描述，不必引入一个新的类来进行管理
   缺点：产品族扩展是一件非常费力的事情。如现在抽象工厂需要引入一个所有产品新的属性 如 价格，那么所有工厂类都需要修改.


4.装饰器模式
  目的：允许开发者在一个存在的对象上添加新的功能，同时不改变对象的结构
  该模式归属于 "结构模式"，因为它相对于已存在的类，扮演一个装饰器"wrapper"
  注意：
    抽象装饰器应该和具体类应该实现同一个接口
    抽象装饰器要持有接口，以便传递请求
    具体装饰器覆盖抽象装饰器，并且调用 super ，以便传递请求
  通俗的说，好的装饰器模式，应该可以"装饰自己", 从而可以满足无限的一层一层装饰，类似于俄罗斯套娃
   优点：装饰类和被装饰类只需要关心自己的业务，实现解耦
        方便动态的扩展功能，提供比 java 继承更多的灵活性
   缺点：功能扩展过多，会产生许多类。
        同时装饰是可以多层装饰的，多层装饰会比较复杂