1.单例模式
2.原型模式
  原型模式属于对象的创建模式。通过给出一个原型对象来指明所有创建的对象的类型，然后用复制这个原型对象的办法创建出更多同类型的对象。
  这就是选型模式的用意。
  Object::clone
  要实现对象的clone，实现Cloneable接口 调用 clone方法即可实现对象的克隆
  但是这种方式只是浅克隆，只是克隆了对象，但是对象内的成员如对象成员变量拷贝前后还是一样的对象。
  -->>> 使用反序列化实现深拷贝 或者在clone方法内部拷贝所有成员
3.工厂模式
 https://blog.csdn.net/u012156116/article/details/80857255
 3.1 简单工厂模式
  简单定义：一个工厂生产所有的工具。这个工厂不是万能的
  我们需要工具的时候，并不需要自己去创造，可以通过工厂获取。
  对创建的对象进行加工处理，而使用的时候并不知道加工细节。
  缺点：业务中很多与对象创建相关的代码，每个方法都要写许多的对应代码。后期很容易导致简单工厂类臃肿，耦合度高。
 3.2 工厂模式
  对简单工厂模式的解耦。
  一个工具由一个工厂生产。
  优点，代码不会耦合到一个类里面。
  缺点同样明显，没增加一个工具，就需要添加一个工厂类。当工具非常多的时候，需要创建的工厂类也非常多。
 3.3 抽象工厂模式
  工厂模式：一个工厂->该工厂只能生产一个产品
  抽象工厂：一个工厂->该工厂能生产一系列的产品
  如：
    查询数据库表 user_profile event 。。等n个表
    工厂模式-> n个工厂 分别针对所有个表的数据库操作
    优点：抽象工厂-> 1个抽象总工厂接口 若干具体工厂接口和若干具体工厂实现。
      一个具体工厂只需要实例化一次。所以修改实例工厂很简单
      同时，具体创建的实例过程与客户端分离。客户端不知道他是怎么来的，由谁创建。
  缺点：如示例代码，如果增加许多表，需要增加对应的对象实体类，sql工厂，

